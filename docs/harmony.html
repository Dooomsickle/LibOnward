<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-03-19T16:26:13.7742384"><title>Harmony | Main</title><script type="application/json" id="virtual-toc-data">[{"id":"getting-methodinfo-objects","level":0,"title":"Getting MethodInfo Objects","anchor":"#getting-methodinfo-objects"},{"id":"hooking","level":0,"title":"Hooking","anchor":"#hooking"},{"id":"alternate-syntax","level":0,"title":"Alternate Syntax","anchor":"#alternate-syntax"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.css" rel="stylesheet"><link rel="manifest" href="site.webmanifest"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Harmony | Main"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Main Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/69/1/harmony.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Harmony | Main"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/69/1/harmony.html#webpage",
    "url": "writerside-documentation/69/1/harmony.html",
    "name": "Harmony | Main",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/69/#website",
    "url": "writerside-documentation/69/",
    "name": "Main Help"
}</script><!-- End Schema.org --></head><body data-id="Harmony" data-main-title="Harmony" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Main 1 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Harmony" id="Harmony.md">Harmony</h1><p id="nrvy8y_2457">Harmony is a .NET library that enables hooking of both MSIL and native functions, which is essential in modding any game.</p><section class="chapter"><h2 id="getting-methodinfo-objects" data-toc="getting-methodinfo-objects">Getting <code class="code" id="nrvy8y_2459">MethodInfo</code> Objects</h2><p id="nrvy8y_2460">C# has reflection capabilities which allow us to get references to types and their members. Before we do any hooking, we need to get references to both the method we want to hook and our method that we want to run.</p><p id="nrvy8y_2461">Fortunately, the language makes this pretty easy:</p><div class="code-block" data-lang="csharp">
using System;
using System.Reflection;
 
public class OurClass
{
    public static void Main()
    {
        var yourMethodInfo = typeof(OurClass).GetMethod(&quot;dummyMethod&quot;, BindingFlags.Static | BindingFlags.NonPublic);
        Console.WriteLine(ourMethod.Name);
    }
 
    private static void dummyMethod(args)
    {
        // do your funny hook things here
    }
}
</div><p id="nrvy8y_2463">Let's analyze that code.</p><div class="code-block" data-lang="csharp">typeof(Demo)</div><p id="nrvy8y_2465">We need the actual type of our class before we can get its methods. The builtin <code class="code" id="nrvy8y_2466">typeof()</code> method does exactly that; it accepts a class name as an argument and outputs its corresponding type (if you couldn't tell already lmfao)</p><p id="nrvy8y_2467">Now that we have that, we call <code class="code" id="nrvy8y_2468">GetMethod(&quot;dummyMethod&quot;, BindingFlags.Static | BindingFlags.NonPublic)</code>.</p><p id="nrvy8y_2469">Woah, that's a lot.</p><p id="nrvy8y_2470">&quot;dummyMethod&quot; represents the name of your method that you want to attach. Preferably you should use the <code class="code" id="nrvy8y_2471">nameof()</code> method instead of just a string, but either works.</p><p id="nrvy8y_2472">Here's the complicated part: BindingFlags. Put simply, BindingFlags tell the reflection runtime what type of members to search for. Here, we specify <code class="code" id="nrvy8y_2473">Static</code> and <code class="code" id="nrvy8y_2474">NonPublic</code>, which is pretty self-explanatory. It'll look for members that have the static modifier (which makes it global, rather than on an instance of the class) and also aren't public.</p><p id="nrvy8y_2475">The typeof method will work on any type, regardless of if they're in the same assembly or not. It should be noted that methods you want to attach can only be static. Hook targets don't have to be.</p><p id="nrvy8y_2476">Now that we have our MethodInfo objects, we can start hooking.</p></section><section class="chapter"><h2 id="hooking" data-toc="hooking">Hooking</h2><p id="nrvy8y_2477">Harmony makes it pretty simple to hook methods. We need an instance of Harmony, the MethodInfo of the target method, and a HarmonyMethod object.</p><p id="nrvy8y_2478">MelonLoader mod classes have an inherited <code class="code" id="nrvy8y_2479">HarmonyInstance</code> field that we can use to do our hooks with, so don't bother creating a new one.</p><p id="nrvy8y_2480">Remember to include 0Harmony.dll in your project and add <code class="code" id="nrvy8y_2481">using HarmonyLib;</code> at the top of your file.</p><p id="nrvy8y_2482">You can create a HarmonyMethod instance with the MethodInfo object of your method (that you learned how to get earlier):</p><div class="code-block" data-lang="csharp">var ourHarmonyMethod = new HarmonyMethod(yourMethodInfo);</div><p id="nrvy8y_2484">We should probably go over the two most important types of hooks before we continue though, along with the basics.</p><section class="chapter"><h3 id="hook-basics" data-toc="hook-basics">Hook Basics</h3><p id="nrvy8y_2485">Hooks have access to the instance of the object the original method was called on (if it isn't static), that instance's fields, and the arguments passed to the method. Let's say we have the following method of a class we want to hook:</p><div class="code-block" data-lang="csharp">
public class HookTarget
{
    public int SomeField = 3;
    public string PoopFartMethod(bool isTrue)
    {
        // method contents...
    }
}
</div><p id="nrvy8y_2487">Now let's make our hook:</p><div class="code-block" data-lang="csharp">
static void OurHook(MyClass __instance, ref bool __isTrue, ref string __result)
{
    // hpohkjjfgjohn hook stuff
}
</div><p id="nrvy8y_2489">Notice the three arguments we've set for our hook.</p><ul class="list _bullet" id="nrvy8y_2490"><li class="list__item" id="nrvy8y_2491"><p>The <code class="code" id="nrvy8y_2492">__instance</code> parameter, as you could imagine, represents the instance that the method was called on. This is equivalent to the <code class="code" id="nrvy8y_2493">this</code> keyword.</p></li><li class="list__item" id="nrvy8y_2494"><p>The <code class="code" id="nrvy8y_2495">__isTrue</code> parameter represents the one by the same name in the original method. The <code class="code" id="nrvy8y_2496">ref</code> qualifier indicates that the value is passed by reference, and therefore we can edit it.</p></li><li class="list__item" id="nrvy8y_2497"><p>Finally, the <code class="code" id="nrvy8y_2498">__result</code> parameter unsurprisingly gives us access to the method's return value. Like the other parameters, you need to pass it with <code class="code" id="nrvy8y_2499">ref</code> to edit it.</p></li></ul><p id="nrvy8y_2500">You can get all the arguments as an object array by defining a parameter <code class="code" id="nrvy8y_2501">object[] __args</code>.</p><p id="nrvy8y_2502">Fields of the instance can be accessed by their name prefixed with three underscores (in this case, it would be <code class="code" id="nrvy8y_2503">int ___SomeField</code>) in the parameter list. Their types must match.</p><p id="nrvy8y_2504">Do note that the __instance parameter is immutable as far as I know and can not be passed by reference.</p></section><section class="chapter"><h3 id="prefix" data-toc="prefix">Prefix</h3><p id="nrvy8y_2505">A prefix hook runs BEFORE the original method is called. You could alter the parameters of it or even skip it entirely.</p><p id="nrvy8y_2506">To skip a method with a prefix hook, it must return false.</p><p id="nrvy8y_2507">This hook sets the result of the method to 4 and then prevents it from running:</p><div class="code-block" data-lang="csharp">
static bool Prefix(ref int __result)
{
    __result = 4;
    return false;
}
</div></section><section class="chapter"><h3 id="postfix" data-toc="postfix">Postfix</h3><p id="nrvy8y_2509">As you can assume, a postfix does all the things a prefix does except it runs AFTER the method does.</p><p id="nrvy8y_2510">You can't skip the method with these, but you CAN see if it was skipped.</p><p id="nrvy8y_2511">This hook checks that:</p><div class="code-block" data-lang="csharp">
static void Postfix(bool __runOriginal)
{
    if (__runOriginal)
        Console.WriteLine(&quot;Method was not skipped&quot;);
}
</div><p id="nrvy8y_2513">Now that you know the difference, we can patch our method.</p><div class="code-block" data-lang="csharp">
// if you don't feel like using positional arguments, you can specify what kind of hook it is with type: methodinfo e.g. prefix: myPrefixInfo
// without using named parameters, the prefix is first and the postfix is second
HarmonyInstance.Patch(originalMethodInfo, postfix: myPostfixInfo);
</div><p id="nrvy8y_2515">You can also unpatch methods if you no longer need them to be hooked:</p><div class="code-block" data-lang="csharp">
HarmonyInstance.Unpatch(originalMethodInfo, myHookMethodInfo);
// you can also unpatch all hooks of a certain type
HarmonyInstance.Unpatch(originalMethodInfo, HarmonyPatchType.Postfix);
</div></section></section><section class="chapter"><h2 id="alternate-syntax" data-toc="alternate-syntax">Alternate Syntax</h2><p id="nrvy8y_2517">You can make your own patch class to keep hooks organized.</p><p id="nrvy8y_2518">HarmonyLib comes with a set of attributes that describe which classes contain hooks to be applied.</p><div class="code-block" data-lang="csharp">
using HarmonyLib;
 
[HarmonyPatch(typeof(HookTargetClass))]
static class MyPatches
{
    [HarmonyPrefix]
    [HarmonyPatch(&quot;targetMethod&quot;)]
    static void Prefix()
    {
        // do your things here
    }
    [HarmonyPostfix]
    [HarmonyPatch(&quot;targetMethod&quot;)]
    static void Postfix()
    {
        // more hook shit :3
    }
}
</div><p id="nrvy8y_2520">It's important to know that when you do this, <code class="code" id="nrvy8y_2521">HarmonyInstance.PatchAll()</code> must be called for them to apply. However, if you're doing this in a MelonMod, it's done for you.</p><p id="nrvy8y_2522">Now that we know how to hook, let's get on to the fun stuff.</p></section><div class="last-modified">Last modified: 19 March 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="introduction.html" class="navigation-links__prev">Introduction</a><a href="basic-object-manipulation.html" class="navigation-links__next">Basic Object Manipulation</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.6.6-b224/app.js"></script></body></html>